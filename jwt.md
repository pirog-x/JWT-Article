# JWT

Структура: 
+ [Что такое JWT](#что-такое-jwt)
+ [Структура JWT](#структура-jwt)
+ [Подпись и проверка JWT](#подпись-и-проверка-jwt)

## Что такое JWT

> **JSON Web Token (JWT)** — это открытый стандарт [(RFC 7519)](https://datatracker.ietf.org/doc/html/rfc7519) для 
создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации 
в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который 
в дальнейшем использует данный токен для подтверждения подлинности аккаунта.

Да, понятнее не стало. JWT токен это способ подтвердить свою личность без нужды обращаться в базу данных. 
А теперь давайте рассмотрим пример из жизни, чтобы было немного понятнее как используют такие токены.

Итак ситуация - у Вас сломалась микроволновка и Вы обратились в гарантийный сервис. Менеджер сказала, что печь 
посмотрят, только чуть-чуть позже, т.к. сейчас у них все мастера занятые и дали талончик на очередь .

<img src="resources/image/ticket_queue.png">

Теперь остаётся просто прийти в сервис в назначенное время и получить тех. обслуживание. 
Но подождите ка, там написанная ближайшая дата 2056 год?!

### Почему JWT токен безопасный?
Да уж, до 2056 года не хочется ждать... Может, можно как-то немного изменить дату, чтобы быстрее получить обслуживание? 
Но как? Вся загвоздка в наборе символов внизу талона - это называется подписью (signature). Она высчитывается 
следующим образом: нужно взять все данные из талона (имя, дату и т.д.), придумать секретный ключ и передать в 
хеш-функцию (это такая функция, которая шифрует исходный текст с помощью ключа в каждый раз одинаковый набор символов,
то есть, изменив хоть один символ, мы получим совершенно другой хеш).

Получается, не зная секретного ключа, мы никак не сможем подделать дату и подпись.


## Структура JWT
JWT состоит из 3 частей - header, payload и signature.

+ **Header** - это JSON в котором содержиться информация о алгоритме шифрования.
+ **Payload** - это JSON в котором содериться информация о пользователе.
+ **Signature** - это хеш, который состоит из header'a, payload'a и секретного ключа пропущенных через криптографическую функцию.

Для того, чтобы передать токен по сети, нам нужно закодировать все три части по base64 и соеденить из через точку.

`header`.`payload`.`signature`


### Header
Заголовок нам нужен, чтобы понять какой алгоритм шифрования нам использовать для проверки токена, а также какой тип
токена к нам пришел. После того, как данные будут считаны, они будут обработаны соответственно.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### Payload
"Полезная нагрузка" нужна для того, чтобы пользователь мог аутентифицировать свою личность. Параметры JSON в payload'e
называються `claim`. Вы можете создать свои собственные клеймы, а можем использовать уже существующие, которые определенны
в стандарте [JWT](https://datatracker.ietf.org/doc/html/rfc7519#section-4).

+ **iss (Issuer)** - тот, кто изготовил токен. Ссылка.
+ **sub (Subject)** - тот, кто делает запрос на сервер.
+ **aud (Audience)** - ссылка на сервер, который может обработать токен (i.e. www.myfunwebapp.com).
+ **exp (Expiration Time)** - время, когда токен перестанет действовать. Указано в epoch millis.
+ **nbf (Not Before)** - время, до которого токен нельзя использовать. Точка времени в будущем в epoch millis.
+ **iat (Issued At)** - время когда токен был выпущен. Epoch millis.
+ **jti (JWT ID)** - это id токена, которое создаёт сервер для дополнительного управления токенам.

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 2714902500
}
```

## Подпись и проверка JWT
Для подписи мы будет использовать стандарт [JWS](https://datatracker.ietf.org/doc/html/rfc7515) (Json Web Signature), это
значит, что я буду подписывать токен сигнатурой (signature, и что header и payload не будут зашифрованные, а просто
декодированы по таблице base64. Алгоритм шифрования будет `HS256(Symmetric) → HMAC using SHA256`.

```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), 256bit-secret)
```

Полученый результат мы тоже кодирует по base64. И соидиняем всё чере точку, вот результат:

`header.payload.signature`

<font color="#fb015b">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</font>.<font color="#d63aff">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</font>.<font color="#00b9f1">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</font>


### Как проверить подленность JWT

Для провеки мы должны взять header и payload с пришедшего токена, выполнить алгоритм указанный в header. Полученный 
результат сравнить с сигнатурой. Если всё совпало - токен валидный.


## Какие проблемы решает JWT

