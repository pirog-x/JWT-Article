# JWT

Структура: 
+ [Что такое JWT](#что-такое-jwt)
+ [Структура JWT](#структура-jwt)
+ [Подпись и проверка JWT](#подпись-и-проверка-jwt)

## Что такое JWT

> **JSON Web Token (JWT)** — это открытый стандарт [(RFC 7519)](https://datatracker.ietf.org/doc/html/rfc7519) для 
создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации 
в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который 
в дальнейшем использует данный токен для подтверждения подлинности аккаунта.

Да, понятнее не стало. JWT токен это способ подтвердить свою личность без нужды обращаться в базу данных. 
А теперь давайте рассмотрим пример из жизни, чтобы было немного понятнее как используют такие токены.

Итак ситуация - у Вас сломалась микроволновка и Вы обратились в гарантийный сервис. Менеджер сказала, что печь 
посмотрят, только чуть-чуть позже, т.к. сейчас у них все мастера занятые и дали талончик на очередь .

<img src="resources/image/ticket_queue.png">

Теперь остаётся просто прийти в сервис в назначенное время и получить тех. обслуживание. 
Но подождите ка, там написанная ближайшая дата 2056 год?!

### Почему JWT токен безопасный?
Да уж, до 2056 года не хочется ждать... Может, можно как-то немного изменить дату, чтобы быстрее получить обслуживание? 
Но как? Вся загвоздка в наборе символов внизу талона - это называется подписью (signature). Она высчитывается 
следующим образом: нужно взять все данные из талона (имя, дату и т.д.), придумать секретный ключ и передать в 
хеш-функцию (это такая функция, которая шифрует исходный текст с помощью ключа в каждый раз одинаковый набор символов,
то есть, изменив хоть один символ, мы получим совершенно другой хеш).

Получается, не зная секретного ключа, мы никак не сможем подделать дату и подпись.


## Структура JWT
JWT состоит из 3 частей - header, payload и signature.

+ **Header** - это JSON в котором содержиться информация о алгоритме шифрования.
+ **Payload** - это JSON в котором содериться информация о пользователе.
+ **Signature** - это хеш, который состоит из header'a, payload'a и секретного ключа пропущенных через криптографическую функцию.

Для того, чтобы передать токен по сети, нам нужно закодировать все три части по base64 и соеденить из через точку.

`header`.`payload`.`signature`


### Header
Заголовок нам нужен, чтобы понять какой алгоритм шифрования нам использовать для проверки токена, а также какой тип
токена к нам пришел. После того, как данные будут считаны, они будут обработаны соответственно.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### Payload
"Полезная нагрузка" нужна для того, чтобы пользователь мог аутентифицировать свою личность. Параметры JSON в payload'e
называються `claim`. Вы можете создать свои собственные клеймы, а можем использовать уже существующие, которые определенны
в стандарте [JWT](https://datatracker.ietf.org/doc/html/rfc7519#section-4).

+ **iss (Issuer)** - тот, кто изготовил токен. Ссылка.
+ **sub (Subject)** - тот, кто делает запрос на сервер.
+ **aud (Audience)** - ссылка на сервер, который может обработать токен (i.e. www.myfunwebapp.com).
+ **exp (Expiration Time)** - время, когда токен перестанет действовать. Указано в epoch millis.
+ **nbf (Not Before)** - время, до которого токен нельзя использовать. Точка времени в будущем в epoch millis.
+ **iat (Issued At)** - время когда токен был выпущен. Epoch millis.
+ **jti (JWT ID)** - это id токена, которое создаёт сервер для дополнительного управления токенам.

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 2714902500
}
```

### Signature
> Подпись(Signature) - это способ подтвердить, что JWT токен валидный.

Для подписи можно использовать криптографические алгоритмы, которые определенны в стандарте 
[JWA](https://datatracker.ietf.org/doc/html/rfc7518) (Json Web Algorithm)

| "alg" Param Value  | Digital Signature or MAC Algorithm             | Implementation Requirements |
|--------------------|------------------------------------------------|-----------------------------|
| HS256              | HMAC using SHA-256                             | Required                    |
| HS384              | HMAC using SHA-384                             | Optional                    |
| HS512              | HMAC using SHA-512                             | Optional                    |
| RS256              | RSASSA-PKCS1-v1_5 using SHA-256                | Recommended                 |
| RS384              | RSASSA-PKCS1-v1_5 using SHA-384                | Optional                    |
| RS512              | RSASSA-PKCS1-v1_5 using SHA-512                | Optional                    |
| ES256              | ECDSA using P-256 and SHA-256                  | Recommended                 |
| ES384              | ECDSA using P-384 and SHA-384                  | Optional                    |
| ES512              | ECDSA using P-521 and SHA-512                  | Optional                    |
| PS256              | RSASSA-PSS using SHA-256 and MGF1 with SHA-256 | Optional                    |
| PS384              | RSASSA-PSS using SHA-384 and MGF1 with SHA-384 | Optional                    |
| PS512              | RSASSA-PSS using SHA-512 and MGF1 with SHA-512 | Optional                    |
| none               | No digital signature or MAC performed          | Optional                    |

В сегодняшнем примере, мы будем использовать HS256. В формуле ниже можно увидеть каким образом создаётся подпись.
```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), 256bit-secret)
```
Давайте расмотрим по этапам:
1. `base64UrlEncode(header) + "." + base64UrlEncode(payload)` - кодируем header и payload по base64 и полученные 
значения соединяем через точку.

    base64 - это таблица кодировки, по этой таблице мы можем преобразовать байты в символы.
2. `256bit-secret` - это наш секретный ключ, он нужен для того, чтобы зашифровать текст(из пункта `1`).
3. `HMACSHA256(...)` - это уже сама функция, которая шифрует текст из пункта `1` с помощью ключа из пункта `2`
    используя алгоритм `HS256`.

То, что вернула функция и есть подпись. Для подписания токена нам нужно закодировать результат функции 
в формате base64 и добавить его в конец токена

`header.payload.signature`

$\color{#fb015b}{eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9}$

**.**

$\color{#d63aff}{eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ}$

**.**

$\color{#00b9f1}{SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c}$

raw:
`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`.`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ`.`SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

Именно в таком виде JWT передаётся по сети.


### Как проверить подленность JWT

Для провеки мы должны взять header и payload с пришедшего токена, выполнить алгоритм указанный в header. Полученный 
результат сравнить с сигнатурой. Если всё совпало - токен валидный.


## Какие проблемы решает JWT

