# JWT

Структура: 
+ [Что такое JWT](#что-такое-jwt)
+ [Структура JWT](#структура-jwt)
+ [Подпись и проверка JWT](#подпись-и-проверка-jwt)


## Что такое JWT

> **JSON Web Token (JWT)** — это открытый стандарт [(RFC 7519)](https://datatracker.ietf.org/doc/html/rfc7519) для 
создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации 
в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который 
в дальнейшем использует данный токен для подтверждения подлинности аккаунта.

Да, понятнее не стало. Давайте расмотрим на примере. К примеру у вас сломалась микроволновка фирмы `Waves` и вы
обратились в гарантийный сервис. Они сказали, что печь посмотрят, только чутка позже, т.к. сейчас у них все мастера
занятые и дали талончик на очередь.
<img src="resources/image/ticket_queue.png">

Да уж, до 2056 не хочеться ждать... Может как-то немного изменить дату, чтобы быстрее получить обслуживание, но как?
На самом деле никак, так как на талоне стоит "подпись" (signature). Да, "n_Z8IEoycj..." это подпись, которая высчитывается 
как хэш значение всех данных написанных на талоне и секретного ключа, который знает только сервис поддержки. Так что не 
вийдет у нас подделать талон, так как при проверке талона на достованость, "подпись" будет совершенно другая, 
прийдётся ждать...


## Структура JWT
JWT состоит из 3 частей - header, payload и signature.

+ HEADER - это json в котором содержиться информация о алгоритме шифрования.
+ PAYLOAD - это json в котором содериться информация о пользователе.
+ SIGNATURE - это хэш (набор рандомных символов), который состоит из header'a, payload'a и секретного ключа.

Для того, чтобы этот токен передать по сети, мы должны его закодировать header и payload по base64url, и соеденить все
три элемента через точку. На пример:

HEADER
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

PAYLOAD
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 2714902500
}
```

Давайте разберём каждый блок поподробнее.

### HEADER
Заголовок нам нужен, чтобы понять какой алгоритм шифрования нам использовать для проверки токена, а так же какой тип
токена к нам пришел. После того, как данные будут считаны - они будут обработаны соответственно.

### PAYLOAD
"Полезная нагрузка" нужна для того, чтобы пользователь мог аторизовать свою личность. Все ключи в json называються `claim`.
В стандарте [JWT](https://datatracker.ietf.org/doc/html/rfc7519#section-4) есть заранее зарегистрированные клеймы:

+ **iss (Issuer)** - тот, кто изготовил токен. Ссылка.
+ **sub (Subject)** - тот, кто делает запрос на сервер. Тоесть ваш id, его создаёт сервер.
+ **aud (Audience)** - ссылка на сервер, которые может обработать токен (i.e. www.myfunwebapp.com).
+ **exp (Expiration Time)** - время, когда токен перестанет действовать. Указано в epoch millis.
+ **nbf (Not Before)** - время, до которого токен нельзя использовать. Точка времени в будущем в epoch millis.
+ **iat (Issued At)** - время когда токен был выпущен. Epoch millis.
+ **jti (JWT ID)** - это id, которое создаёт наш сервер для дополнительного управления токенами.


## Подпись и проверка JWT
Для подписи мы будет использовать стандарт [JWS](https://datatracker.ietf.org/doc/html/rfc7515) (Json Web Signature), это
значит, что я буду подписывать токен сигнатурой (signature, и что header и payload не будут зашифрованные, а просто
декодированы по таблице base64. Алгоритм шифрования будет `HS256(Symmetric) → HMAC using SHA256`.

```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), 256bit-secret)
```

Полученый результат мы тоже кодирует по base64. И соидиняем всё чере точку, вот результат:

`header.payload.signature`

<font color="#fb015b">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</font>.<font color="#d63aff">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</font>.<font color="#00b9f1">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</font>


### Как проверить подленность JWT

Для провеки мы должны взять header и payload с пришедшего токена, выполнить алгоритм указанный в header. Полученный 
результат сравнить с сигнатурой. Если всё совпало - токен валидный.


## Какие проблемы решает JWT

